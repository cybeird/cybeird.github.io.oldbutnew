{"meta":{"title":"Sundedi's Blog","subtitle":"Do you want something to play?","description":"Better to run than curse the road.","author":"Sundedi","url":"http://cybeird.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-08-25T00:51:08.000Z","updated":"2021-08-25T00:51:39.420Z","comments":true,"path":"about/index.html","permalink":"http://cybeird.github.io/about/","excerpt":"","text":"欢迎"},{"title":"分类","date":"2021-08-25T01:50:00.000Z","updated":"2021-09-08T07:17:20.683Z","comments":false,"path":"categories/index.html","permalink":"http://cybeird.github.io/categories/","excerpt":"","text":""},{"title":"标签","date":"2021-08-25T01:49:25.000Z","updated":"2021-09-08T07:17:47.590Z","comments":false,"path":"tags/index.html","permalink":"http://cybeird.github.io/tags/","excerpt":"","text":""},{"title":"schedule","date":"2021-08-25T01:57:36.000Z","updated":"2021-08-25T01:57:36.032Z","comments":true,"path":"schedule/index.html","permalink":"http://cybeird.github.io/schedule/","excerpt":"","text":""}],"posts":[{"title":"考还是不考，这是个问题","slug":"kaoyan-or-not","date":"2021-09-09T12:54:24.000Z","updated":"2021-09-09T13:08:47.533Z","comments":true,"path":"Post/kaoyan-or-not/","link":"","permalink":"http://cybeird.github.io/Post/kaoyan-or-not/","excerpt":"","text":"FF14短期目标很简单，通过死宫赶紧搞到50级，这样就能换上一套与进度相仿的装备做主线了。而且这时循环基本也齐了，直接照抄即可 动规希望明天一天能把这个玩意搞完 学习无 上午不知道干嘛去了，与其浪费时间在哔哩哔哩上还不如肝肝FF14。中午开了一罐红牛，现在看来简直是浪费时间浪费生命。 焦虑我觉得今天老师说的挺对的，这种东西都是潜移默化的（顺便提一句：我们专业的人才培养方案设计的真是太牛啦！） 不知道是什么的东西，先摆在这里（好像是计算时间复杂度的东西） if f(n) ∈ Θ(n^d^) d&gt;=0 ​ { Θ(n^d^) a&lt;b^d^ T(n) ∈ { Θ(n^d^logn) a=b^d^ ​ { Θ(n^logba^) a&gt;b^d^","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[]},{"title":"从next离开，但是感觉前途渺茫","slug":"next-step-to-another","date":"2021-09-08T07:53:04.000Z","updated":"2021-09-08T07:56:34.312Z","comments":true,"path":"Post/next-step-to-another/","link":"","permalink":"http://cybeird.github.io/Post/next-step-to-another/","excerpt":"","text":"算法思想草记对于局部有序的数列，可以考虑选择归并排序来进行进一步的处理 下一篇文章大纲主题转战hexo 的主题里 next 可以说是我从一入坑便用到现在了，即便是遇见了各种各样的问题我也并未放弃（当然确实也耗费了很多的时间去解决，虽然最后的解决方法都是重装），而今天我决定跨出历史性的一步：换个主题 Volantis 初探博客结构梳理趁着博文还不算太多，决定一下整个博客的使用架构-AfterRead–SWE–AA-Post -各种牢骚那么问题来了，是否要用英文来写博客呢 如何插入图片以及数据流图（这个倒是真的蛮方便的）动归初探如何不让自己的内心不外界干扰 多记录少空想，本子记录随心想到的内容并及时整理成大纲，日后再将其转化成博文 学习CCF考试报名遇见了很大的挫折，好™烦啊","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://cybeird.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://cybeird.github.io/tags/next/"},{"name":"Self-Contribute","slug":"Self-Contribute","permalink":"http://cybeird.github.io/tags/Self-Contribute/"},{"name":"Volantis","slug":"Volantis","permalink":"http://cybeird.github.io/tags/Volantis/"}]},{"title":"看来只有我处于疯狂颓废的状态","slug":"everoneslearning-expert-me","date":"2021-09-07T11:32:09.000Z","updated":"2021-09-07T11:44:36.917Z","comments":true,"path":"Post/everoneslearning-expert-me/","link":"","permalink":"http://cybeird.github.io/Post/everoneslearning-expert-me/","excerpt":"","text":"学习图书馆人这么多我是没想到的，基本可以说是满员了，回想上个学期的图书馆人员情况，真是有趣啊。 算法分析这门课还是有必要好好上的。 原本想看看政治的，但是好™热啊 博客遇见了未知的错误，现在网有点差，得之后再去解决了 初步判断可能是配置文件写的有问题，但是很难去进行验证（难道趁此机会换个别的主题？） 消费在食堂一楼发现了一家价格非常实惠而且蛮不错的面条，可以常驻了，因为真的很便宜 快递逐步的都要到了 习惯餐前消毒的习惯实在是很难养成，但是现在的问题是我真的得洗个澡了（而且图书馆现在依旧好热啊） 多喝水，脸上起了两个痘痘好难受","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"next","slug":"next","permalink":"http://cybeird.github.io/tags/next/"}]},{"title":"算法第二课-二分后查找","slug":"algorithm-analysis-learning-2","date":"2021-09-07T00:21:43.000Z","updated":"2021-09-07T01:30:40.084Z","comments":true,"path":"AfterRead/Algorithm-Analysis/algorithm-analysis-learning-2/","link":"","permalink":"http://cybeird.github.io/AfterRead/Algorithm-Analysis/algorithm-analysis-learning-2/","excerpt":"","text":"吐槽老师见我们有的人买了实验报告书而有的人没买略微有些惊奇，我还在想代码的事情，结果老师告诉我们她填这本书完全是为了自己看看的，哈哈哈哈哈哈哈我是伞兵。不过老师随即表示这书买了也不亏，如果你想练练算法题不也方便许多吗。我觉得老师说的很有道理，然后打开了PTA 现在是上课一个小时后，看见长青大佬在疯狂刷题，我的心情十分复杂，根本无法沉下心来做题了T。T 算法核心与分析二分搜索，就是通过不断二分然后比较的方式来进行序列内元素的查找： 首先找到数组内的中间元素mid开始比较，然后向左从begin到mid，向右从mid+1到end逐步分治下去。最终比较到第一个所需的数字并返回其位置（如果数组内有多个相似的值就没办法了，我个人觉得可以写个优先队列来存储位置，但是我实在是太懒啦） 算法代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define N 10using namespace std;int binarySearch(int *a, int begin, int end, int x)&#123; if(end - begin &gt;= 0) while(begin &lt; end) &#123; int mid = (begin + 1 + end)/2; if (x != a[begin]) &#123; if(binarySearch(a, begin, mid, x) != -1)return binarySearch(a, begin, mid, x); else return binarySearch(a, mid+1, end, x); &#125; else return begin; &#125; else return -1;&#125;int main()&#123; int a[N]; srand(time(0)); cout&lt;&lt; &quot;before&quot; &lt;&lt; endl ; for(int i = 1; i &lt;= N; i++) &#123; a[i]=rand()%100; cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; // 在a数组中生成了100个随机数 // 归并排序我们已经写过一个可以运行的了，这次就按照老师的要求写一个二分查找吧 cout &lt;&lt; endl &lt;&lt; &quot;which number do you like?&quot; &lt;&lt; endl; int num;cin &gt;&gt; num; cout &lt;&lt; binarySearch(a, 1, N, num); return 0;&#125; 报错的原因是因为第一个函数被程序判断为没有写返回值（如果实在看不顺眼可以写个return 0;不过这个永远也不会被用到罢了） 原本我是打算每次分治之后先检查第一个值然后再去接着二分的，但是仔细想想若如此做反而是浪费了更多的时间去进行重复的比较，所以最后还是按照这种方式来写。 时间复杂度和空间复杂度对于n长的序列进行二分搜索最差的情况也就进行了logn次查找，所以时间复杂度应该是O(logn)吧 空间复杂度基本就用了一个用来存数列的数组，也就是O(n)","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"},{"name":"Algorithm Analysis","slug":"AfterRead/Algorithm-Analysis","permalink":"http://cybeird.github.io/categories/AfterRead/Algorithm-Analysis/"}],"tags":[{"name":"c艹","slug":"c艹","permalink":"http://cybeird.github.io/tags/c%E8%89%B9/"},{"name":"algorithm","slug":"algorithm","permalink":"http://cybeird.github.io/tags/algorithm/"},{"name":"binarySearch","slug":"binarySearch","permalink":"http://cybeird.github.io/tags/binarySearch/"}]},{"title":"新学期快乐！","slug":"happy-new-term","date":"2021-09-06T15:12:45.000Z","updated":"2021-09-06T15:24:32.720Z","comments":true,"path":"Post/happy-new-term/","link":"","permalink":"http://cybeird.github.io/Post/happy-new-term/","excerpt":"","text":"学习完全没在状态，除非不带手机 和小组成员分配了软工实验的任务，决定三个人进行结组 我分配到的是第4和第5实验，不过这个并不着急 FF14决定不玩赤魔了，还是玩武僧试探一番 赤魔我个人觉得问题主要有两个： 触发只有50%略微看脸不说还很容易打乱节奏，虽然本身对节奏要求不高，但是一旦损失就会牺牲大量输出，而即便运气很好也打不出很高输出 职业特性太拉跨，快速吟唱虽然看起来很牛，但是反而加大了施法的要求和压力，我原本以为有这个技能的赤魔能减少处于吟唱的时间的，结果反而为了充分利用职业特性成为了一个全程都在吟唱的魔法师，瞬发的不消耗魔元的技能基本都是冲上去和跳回来，非常离谱 空调空调的使用确实很泛滥，不过双清同学的骚操作我也确实没看懂：每次出门前都要把空调顺手关闭，回来则立马打开，欸，一言难尽，不过他也确实是这种人，总在很小的事情上恶心你，这就是我孙子搬出去住的原因吧 为此我还是尽量使用我孙子的充电插头吧 消费我每天要吃好多钱钱。。。 不过去超市的频次倒是大幅度下降 想去理个发","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[{"name":"FF14","slug":"FF14","permalink":"http://cybeird.github.io/tags/FF14/"},{"name":"SWE","slug":"SWE","permalink":"http://cybeird.github.io/tags/SWE/"}]},{"title":"今天血压起来了，老鼠屎","slug":"are-you-nt","date":"2021-09-05T14:47:39.000Z","updated":"2021-09-05T14:57:50.566Z","comments":true,"path":"Post/are-you-nt/","link":"","permalink":"http://cybeird.github.io/Post/are-you-nt/","excerpt":"","text":"血压关于血压这方面，我是真没想到的，如果这大冷天的还要开冷气，如果电费起飞我是真的打算跑路的，太受不了了。特别是孙子告诉我的lss约炮事件，我™真的是接受不能，现在的这一代人已经开放到了这种程度了吗，吐了，太™操蛋了。 而且我发现我真是无法忍受lss说的任何一句话了，关于开门随手不关门这种事情真的不是第一次说了，但是™的你说个对不起有个鸡巴用啊，你是nt吗，每次都说对不起不好意思，那你倒是改啊，原谅你个jb，你做错了不改就是给我磕个头也不顶屎啊，我真™服了，我能把你妈坟掘了然后说声不好意思吗？哦哦哦，不好意思，你没妈啊。 学校又把操场围墙加固了一番，不过即便如此也挡不住学生们出去的心，哈哈哈。 学习学习是不可能学习的，今天下午去了趟图书馆，图书馆一楼是开放的，而剩下的并没有开放，明天还是去看看吧，上午就不带苏菲了，中午带上刚好可以上实验课。 消费最近的消费水平维持一般，我感觉要是能忍到双十一可以考虑爆发一波爽一爽，也算是有个盼头了。 搬出去确实很烧钱，不过空调吗。。。很难说啊","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[]},{"title":"周六的快乐我总是无法感受完全","slug":"ff14-and-happy-life","date":"2021-09-04T12:55:24.000Z","updated":"2021-09-04T13:18:26.741Z","comments":true,"path":"Post/ff14-and-happy-life/","link":"","permalink":"http://cybeird.github.io/Post/ff14-and-happy-life/","excerpt":"","text":"焦虑（学习）学不进去玩不进去，真™难受 这就是适应障碍吗，老混子了 但是周围的同学都在疯狂好好学习，他喵的救我一个天天想着打游戏 整理一下要打印的素材，按照专业课（具体来说应该是操作系统），数学（这个暂时不需要打印），英语（这个素材太多了），政治（这个需求量倒是蛮大的） 操作系统思维导图 政治课件的PPT 生活六十四同学居然打扫了卫生，这是我没想到的 洗手液到货了，感觉蛮不错的，生活品质++？ 想入手bose大鲨，确实好贵，难顶啊，我感觉完全没有必要顶到双十一，但是这种事情实在是很难说 健康如果说我每天能起床的话，那么入睡就很难 红牛要到货了 比较难过的就是运动根本无法坚持下去了","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[{"name":"daily","slug":"daily","permalink":"http://cybeird.github.io/tags/daily/"},{"name":"FF14","slug":"FF14","permalink":"http://cybeird.github.io/tags/FF14/"}]},{"title":"一 软件工程概述","slug":"software-engineering-learning-2","date":"2021-09-03T10:01:45.000Z","updated":"2021-09-03T10:23:37.306Z","comments":true,"path":"AfterRead/Software-Engineering/software-engineering-learning-2/","link":"","permalink":"http://cybeird.github.io/AfterRead/Software-Engineering/software-engineering-learning-2/","excerpt":"","text":"软件危机软件开发的特性 难以描述性 缺乏可见性 复杂性 变化性 风险性 强合作性 软件危机在软件开发过程中所存在的周期长、成本高、质量低等问题 缺乏计划性 软件需求获取不充分，不准确 缺乏团队开发的合作、协调能力 缺乏良好的软件质量评测手段 可维护性差 可复用性差 开发过程不规范 缺乏自动化的工具来协助开发 缺乏变更管理措施 缺乏风险管理手段 软件工程的概念软件工程是以质量为核心，为了经济地开发满足客户需求的软件而研究、建立和应用的系统化的、有规则的、可度量的和可控制的工程原则、方法，设计软件过程、项目管理、开发方法、开发工具，甚至企业文化等各个方面。 由此可以拆分为 以质量为中心 经济性 满足客户需求 研究、建立和应用 系统化 有规则 可度量 可控制 软件过程 项目管理 开发方法 开发工具 企业文化","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"},{"name":"Software Engineering","slug":"AfterRead/Software-Engineering","permalink":"http://cybeird.github.io/categories/AfterRead/Software-Engineering/"}],"tags":[{"name":"SWE","slug":"SWE","permalink":"http://cybeird.github.io/tags/SWE/"}]},{"title":"见鬼，这些符号到底有什么不同？","slug":"diffence-between-many-simple","date":"2021-09-03T04:11:48.000Z","updated":"2021-09-07T10:41:48.095Z","comments":true,"path":"AfterRead/diffence-between-many-simple/","link":"","permalink":"http://cybeird.github.io/AfterRead/diffence-between-many-simple/","excerpt":"","text":"引子–二叉树交换左右子树昨日的题目大概是这样？ 12345678910111213void change(bitnode *&amp;t, int x, int y)&#123; bitnode *temp = new bitnode; if (t) &#123; if (t==NULL)return//若是根节点为NULL，递归结束 temp = t-&gt;lchild; t-&gt;lchild = t-&gt;rchild; t-&gt;rchild = temp; change(t-&gt;lchild, x, y); change(t-&gt;rchild, x, y); &#125;&#125; （代码是我网上dang来的，我懒得传图片了）只不过在第一行的位置应该是忘记写了*，据我回忆的几个细节大概是这样的 不完全代码： 12345678void switchLRTree(bitree &amp;T)&#123; bitnode *temp = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = temp; switchLRTree ..... .....&#125; 问题主要出在两处，一个是函数传入的是树的地址而非指针，以至于在函数运行过程中修改成了树的值在函数中所被指向的指针的值。感觉不太好理解，没关系，我们先再来复习一下关于在初学函数时所使用的形参和实参的概念。 形参和实参对于一个函数，内部所使用的变量被成为局部变量，函数外所定义的变量则是全局变量，相对于全局变量而言，局部变量仅能在函数内部使用。而在函数的调用过程中，函数所定义并使用的变量是形参，在使用函数调入数据时，会将实参的值赋予形参后，在函数内部进行运算，但是却只会修改函数内部的形参，无法对实参产生影响。 也就是如果我们想要用函数修改函数之外的变量的值，就必须要使用指针，传入变量的地址而非值，通过地址准确修改其所指向的值。（在二叉树这里的swap如果按照惯性思维很容易想岔，因为调用的是指针的指针，也就是在第三层） 指针和地址那么怎么才能升到大气层呢？我们还是得仔细考虑一下指针和地址的关系（*和&amp;） 变量都放置在内存中，内存的每个字节都有一个成为地址的编号，而变量的地址则是这一定数目的字节的第一个的地址。 使用int* a则会定义一个指向int型变量的指针 变量名前面加&amp;则是去该变量的地址 倘若在这之后使用a = &amp;b，则是将变量b的地址存放到a之中，这时，*a便是a所指向的变量。（这里仅仅是指向的变量，而非变量的值，大概就是人名和人身的区别吧） 因此回到引子，如果我们想要交换两个普通的变量的值，则需要在swap函数中如此定义 1void swap(int* a, int* b); % cq % 当然这里需要注意的是，指针虽然也是一种变量，但是却不推荐拿来直接用(比如定义一个整形指针i，然后给*i赋值当整形变量用)，因为你给指针赋值前他是不确定的，搞不好他所代表的内存单元偏偏就不能写入呢？ % endcq % 结构体以及之后的二叉树当swap和二叉树交错在一起，事情就变得更加棘手了，不过我们首先来看看结构体里的指针是怎么搞的。 this 指向当前变量的指针 this-&gt;x 当前对象的成员变量x （等价于(*this).x） 这个时候再回去看文章开头的代码，发现好像有些许不太优雅的地方，修改如下 123456789101112void change(bitnode *t, int x, int y)&#123; bitnode *temp = new bitnode; if (t) &#123; temp = t-&gt;lchild; t-&gt;lchild = t-&gt;rchild; t-&gt;rchild = temp; change(t-&gt;lchild, x, y); change(t-&gt;rchild, x, y); &#125;&#125; 在二叉树定义中，节点的类型是bitnode的话，左右子节点的类型就是bitnode *，也就是指向节点类型的指针。所以指针对指针，值对值，不能搞混。 （好™复杂） 所以错在两处，函数应当调入指针，然后用结构体构造好temp后再用来倒腾。","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"}],"tags":[{"name":"c艹","slug":"c艹","permalink":"http://cybeird.github.io/tags/c%E8%89%B9/"}]},{"title":"感叹这操蛋的生活--以及探索一番markdown的技巧","slug":"explore-hexo-life-fuckegg","date":"2021-09-03T03:57:12.000Z","updated":"2021-09-07T10:38:11.770Z","comments":true,"path":"AfterRead/explore-hexo-life-fuckegg/","link":"","permalink":"http://cybeird.github.io/AfterRead/explore-hexo-life-fuckegg/","excerpt":"","text":"Hexo相关的markdown语法引用文章12&#123;% post_path filename %&#125;&#123;% post_link filename [title] [escape] %&#125; 在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。 默认链接文字是文章的标题，你也可以自定义要显示的文本。 链接使用文章的标题1&#123;% post_link there-is-no-time-to-play %&#125; % post_link there-is-no-time-to-play % 链接使用自定义文字1&#123;% post_link there-is-no-time-to-play &#x27;通往文章的链接&#x27; %&#125; % post_link there-is-no-time-to-play ‘通往文章的链接’ % 感叹生活操蛋的宿舍今天回到宿舍发现eggfucker正在开着门开着窗户盖着被子吹空调，我™觉得就离谱，™的整个就是一个脑瘫吧，交流起来也和脑瘫一样，我只感觉心累，艹。 买个包得了​ 如果我想要长久的往各处来回跑，搞一个靠谱的包是必然的，这个我得深思熟虑一番，以免最后浪费金钱精力。 ff14看起来很不错的游戏，准备搞个赤魔法师尝试一番","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"markdown","slug":"markdown","permalink":"http://cybeird.github.io/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://cybeird.github.io/tags/hexo/"}]},{"title":"算法第一课-分治下的归并","slug":"algorithm-analysis-learning-1","date":"2021-09-02T09:00:49.000Z","updated":"2021-09-03T04:12:36.882Z","comments":true,"path":"AfterRead/Algorithm-Analysis/algorithm-analysis-learning-1/","link":"","permalink":"http://cybeird.github.io/AfterRead/Algorithm-Analysis/algorithm-analysis-learning-1/","excerpt":"","text":"核心思想归并排序的核心操作是归并（一般是二路归并），首先将待排序数列分割成若干个小子序列，在对最小的子序列进行完合并操作后，再将这些有序表逐步合并成为最终的有序序列。这个算法在老师的PPT上好像是叫做合并排序，本质上是一样的。 具体分析题目要求随机生成n（例如100）个数，利用分治的思想设计算法进行排序，并分析算法的复杂度 代码实现及思路初步代码思路为下 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;ctime&gt;#define N 100using namespace std;int a[10005], b[10005] = &#123;0&#125;;void mergesort(int *ar, int begin, int end)&#123; if(begin &lt; end) &#123; //保证数组还有的分 int i = (end + begin)/2; mergesort(ar, begin, i); mergesort(ar, i+1, end); //找中点，然后分治 for(int l = begin; l &lt;= end; l++) b[l] = a[l]; //将合并后的数列放到原数列 int j = begin, k = i+1; for(int n = begin; n &lt;= end; n++) &#123; if(j &gt; i) a[n] = b[k++]; else if(k &gt; end) a[n] = b[j++]; else if(b[j] &lt; b[k]) a[n] = b[j++]; else a[n] = b[k++]; &#125; //将两个有序数列合并成一个有序数列 &#125;&#125;int main()&#123; srand(time(0)); cout&lt;&lt; &quot;before&quot; &lt;&lt; endl ; for(int i = 1; i &lt;= N; i++) &#123; a[i]=rand()%100; cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl &lt;&lt; endl&lt;&lt; &quot;after&quot; &lt;&lt; endl; // 在a数组中生成了100个随机数 // 分治的思想中，由于c++的STL库中自有快速排序，所以我选择写一个简单的合并排序 mergesort(a, 1, N); for(int i = 1; i &lt;= N; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; return 0;&#125; 先利用ctime库里的rand()函数生成100个随机数。 再写一个归并排序，首先判断是否是最小数列，否则便通过递归调用本身继续分治，然后再将分治后的两个有序数列进行合并，最终完成排序 算法空间复杂度和时间复杂度分析空间复杂度使用了两个相当于数据量大小的一维数组，因此是O(n) 时间复杂度在归并的过程中，每次进行一个层级的归并操作的时间复杂度都是O(n)，而由于是二分的思想，所以归并的层级总共有log2n层，也就是执行了log2n次归并操作，最终的时间复杂度便是O(nlog2n) ​","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"},{"name":"Algorithm Analysis","slug":"AfterRead/Algorithm-Analysis","permalink":"http://cybeird.github.io/categories/AfterRead/Algorithm-Analysis/"}],"tags":[{"name":"c艹","slug":"c艹","permalink":"http://cybeird.github.io/tags/c%E8%89%B9/"},{"name":"algorithm","slug":"algorithm","permalink":"http://cybeird.github.io/tags/algorithm/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://cybeird.github.io/tags/Divide-and-Conquer/"},{"name":"mergeSort","slug":"mergeSort","permalink":"http://cybeird.github.io/tags/mergeSort/"}]},{"title":"怎样将博客内容相关的源文件保存在Github上","slug":"how-save-blog-github","date":"2021-09-02T01:06:20.000Z","updated":"2021-09-04T13:12:35.689Z","comments":true,"path":"AfterRead/how-save-blog-github/","link":"","permalink":"http://cybeird.github.io/AfterRead/how-save-blog-github/","excerpt":"","text":"前情提要首先，我们要知道哪些文件是可替代的，哪些文件是用户配置之后需要保留的 1234- scaffolds ##新建博客的模板文件- source ##博客上传中的所有内容文件，也可以放一些你自己写的html- themes ##所有的主题文件- _config.yml ##博客的配置文件 插件安装不过你不知道哪些需要保留应该也无关紧要，因为我们今天使用的是git-deployer-git这款插件，首先使用下列语句来进行安装 1npm install hexo-deployer-git --save 使用介绍在博客源文件的_config.yml中进行配置 123456789101112131415161718192021222324252627282930313233343536# 你可以这样使用:deploy: type: git #自行选择自己部署的网站 repo: &lt;项目地址&gt; #https://github.com/用户名/项目名.git branch: [分支名字] #如果使用的GitHub，将会默认使用gh-pages，不然一般都是master token: &#x27;&#x27; message: [信息] #提交时的信息，默认是Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125; name: [git的用户名] email: [git的邮箱] extend_dirs: [extend directory] #在此处设置要部署的目录 ignore_hidden: false # 默认是true ignore_pattern: regexp # 在进行部署时将要自动忽略的文件，regexp代表全部# 或者这样:deploy: type: git message: [信息] repo: &lt;项目地址&gt;[,分支名字] extend_dirs: - [extend directory] - [another extend directory] ignore_hidden: public: false [extend directory]: true [another extend directory]: false ignore_pattern: [folder]: regexp # or you could specify the ignore_pattern under a certain directory# 或者进行多项仓库的统一配置deploy: repo: # Either syntax is supported [仓库名]: &lt;项目地址&gt;[,分支名字] [仓库名]: url: &lt;项目地址&gt; branch: [分支名字] 所以保存源目录的方式就很简单了，在GitHub上创立两个分支gh-pages和master（自然，你可以使用任意你想要的名字，把配置文件修改一番即可）然后按照一下方式修改配置文件（部署两次到两个分支去） gh-pages是用来展示博客网站的分支，所以记得在项目的Settings中的Pages选项中将Source设置成 Branch:gh-pages 和/root(如果你有其他想法也可以设置成别的) master文件中存储的即是所有需要保存的文件，需要的时候使用hexo init一个文件然后把master拷下来覆盖即可。 最终代码123456789101112# _config.yamldeploy: - type: git repo: git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git branch: gh-pages - type: git repo: git@github.com:&lt;用户名&gt;/&lt;用户名&gt;.github.io.git branch: master extend_dirs: / ignore_hidden: false ignore_pattern: public: . 注意事项记得将博客源文件和主题源文件中的.git文件夹删除，如果有的话 待解决 字体文件只能本机查看 每次部署都需要删除.deploy_git,有点麻烦且还没搞懂 1rm -rf .deploy_git","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://cybeird.github.io/tags/hexo/"},{"name":"Github","slug":"Github","permalink":"http://cybeird.github.io/tags/Github/"},{"name":"git","slug":"git","permalink":"http://cybeird.github.io/tags/git/"}]},{"title":"走在毁灭的悬崖边缘","slug":"there-is-no-time-to-play","date":"2021-09-02T00:32:16.000Z","updated":"2021-09-07T10:42:09.958Z","comments":true,"path":"Post/there-is-no-time-to-play/","link":"","permalink":"http://cybeird.github.io/Post/there-is-no-time-to-play/","excerpt":"","text":"没错，人已经要没了，二战也是不可能二战的了。 9月17日进行CCF能力认证考试，12日之前我还需要做出最终的抉择。 我希望我能一天学完全部的操作系统和数学，然后疯狂搞C艹，最后直接起飞，只可惜这些都毫无意义。 脑子不转了，待会再写吧。","categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"}],"tags":[{"name":"DOOM","slug":"DOOM","permalink":"http://cybeird.github.io/tags/DOOM/"}]},{"title":"关于markdown中使用思维导图的测试与研究","slug":"mermaid-text","date":"2021-08-25T07:25:39.000Z","updated":"2021-08-25T07:53:10.164Z","comments":true,"path":"AfterRead/mermaid-text/","link":"","permalink":"http://cybeird.github.io/AfterRead/mermaid-text/","excerpt":"","text":"mermaid的markdown语法graph LRA[方块] –&gt; B(圆块)B –&gt; C{菱形}C –&gt; |1| D[方块1]C –&gt; |2| E[方块2] 12345graph LRA[方块] --&gt; B(圆块)B --&gt; C&#123;菱形&#125;C --&gt; |1| D[方块1]C --&gt; |2| E[方块2] 很遗憾，上述语法只能在typora中使用，hexo中是看不到的 只不过可以通过 1npm install hexo-simple-mindmap 的方式安装一个使用起来相对简单的思维导图插件，顺便也测试一下 12345678910&#123;% pullquote mindmap mindmap-md %&#125;- [Hexo 的思维导图插件](https://hunterx.xyz/hexo-simple-mindmap-plugin-intro.html) - 前言 - 使用方法 - 一 - 二 - 三 - 太长不看 - 参考资料&#123;% endpullquote %&#125; 内存管理 程序执行过程 编译、链接、装入 逻辑地址和物理地址 扩充内存————覆盖与交换 连续分配 单一连续分配 固定分区分配————内部碎片 动态分区分配 外部碎片 分配算法：首次、最佳、最坏、邻近适应 非连续分配 页式存储管理 概念：页面、地址结构、页表 地址变化机构及变换过程 快表 段页式存储管理————段表、地址变换机构、段的共享与保护 段页式存储管理————段表、页表 虚拟内存 概念 局部性原理 特征：多次性、对换性、虚拟性 请求分页 组成：页表机构、缺页中断机构、地址变换机构 页面置换算法 最佳置换（OPT） 先进先出（FIFO）————Belady异常 最近最久未使用（LRU） 时钟（CLOCK）算法 页面分配策略————预调页策略、请求调页策略 抖动、工作集 实在是太大了，不太好用，只能轻量级的使用一下，还算可以吧","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"markdown","slug":"markdown","permalink":"http://cybeird.github.io/tags/markdown/"},{"name":"mermaid","slug":"mermaid","permalink":"http://cybeird.github.io/tags/mermaid/"}]},{"title":"软工第一课-概述与软件危机","slug":"software-engineering-learning-1","date":"2021-08-25T02:06:53.000Z","updated":"2021-09-03T10:02:18.759Z","comments":true,"path":"AfterRead/Software-Engineering/software-engineering-learning-1/","link":"","permalink":"http://cybeird.github.io/AfterRead/Software-Engineering/software-engineering-learning-1/","excerpt":"","text":"重新来过了，之前的博客因为我实在是太懒了，以致于没有把源文件从阿里云上拷贝下来，现在服务器已经被释出了，心情复杂。旧的文件我全放在.oldold项目里了，正如上次一样。 实际上这次课一直在捣鼓捣鼓博客，根本没在好好听，不过第一节课不算很深奥，我就照着ppt和课本大概梳理一下，顺便也把课后作业写咯。 软件工程学科发展历史概念提出 1968年NATO会议提出概念 1972年IEEE-CS出版学报 学科雏形 上世纪70年代末，美国加入研究生教育计划 1991年被ACM和IEEE/CS列入计算学科 学科确立 2004年8月 被IEEE-CS和ACM给出（SWEBOK[^10个领域]和SEEK） 软件工程、计算机科学、计算机工程、信息系统、信息技术 并列 软件工程学概述软件工程是指导计算机软件开发与维护的一门工程学科 工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架等。 软件危机软件工程学自“软件危机”始 软件危机介绍软件的发展 程序设计阶段 程序系统阶段 软件工程阶段 什么？指在计算机软件的开发和维护过程中，所遇见的一系列严重问题。 如何开发软件-&gt;以满足日益增长的需求 如何维护软件-&gt;软件数量不断膨胀 典型表现 开发费用和进度难以估算控制导致超出预算 需求分析不充分导致用户不满意最终产品 质量难以保证；软件质量保证技术没能应用到开发全过程 维护困难(常常是不可维护的) 未保留适当的文档资料 文档的作用软件开发管理人员:用于管理和评价软件开发工程的进展状况软件开发人员:用于开发人员对各个阶段的工作都进行周密思考、全盘权衡、从而减少返工。并且可在开发早期发现错误和不一致性，便于及时加以纠正软件维护人员:软件维护的依据 软件成本在计算机系统总成本的比例逐年上升 软件开发生产率提高速度不及计算机应用普及速度 产生原因本身特点与硬件不同 不可见性 是设计开发的逻辑产品 不会“磨损”，但是回退化(问题的隐蔽性) 开发和运行依赖于特点的计算机系统环境 具有可复用性 与一般程序不同 规模庞大，复杂 大型软件开发既有技术问题也有社会问题开发与维护的方法不正确 对需求获取不正确 认为软件开发就是写程序并设法使之运行 软件开发只要依靠个别编程高手就能完成 轻视软件维护 维护费用往往占据总费用的55%-75%，提高软件的可维护性是重要目标 其他原因 软件开发尚未完全摆脱手工艺的开发方式。 软件成本相当昂贵，主要依靠大量复杂的、高强度的脑力劳动 软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性。 消除途径 对计算机软件有正确的认识，彻底消除“软件就是程序”的错误观念。 软件=程序+数据+文档程序是能够完成预定功能和性能的可执行的指令序列；数据是使程序能够适当地处理信息的数据结构；文档是开发、使用和维护程序所需要的图文资料 充分认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，不是个人独立的劳动。 推广和使用在实践中总结出来的软件开发的成功技术和方法。 开发和使用更好的软件工具 结论软件工程正是从管理和技术两方面研究如何更好地开发和维护计算机软件的。按工程化的原则和方法组织软件开发工作是有效的，是摆脱软件危机的一个主要出路。 [^10个领域]: 需求 设计 构造 测试 维护 配置管理 工程管理 工程过程 工程工具和方法 质量","categories":[{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"},{"name":"Software Engineering","slug":"AfterRead/Software-Engineering","permalink":"http://cybeird.github.io/categories/AfterRead/Software-Engineering/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://cybeird.github.io/tags/hexo/"},{"name":"SWE","slug":"SWE","permalink":"http://cybeird.github.io/tags/SWE/"},{"name":"next","slug":"next","permalink":"http://cybeird.github.io/tags/next/"}]}],"categories":[{"name":"Post","slug":"Post","permalink":"http://cybeird.github.io/categories/Post/"},{"name":"AfterRead","slug":"AfterRead","permalink":"http://cybeird.github.io/categories/AfterRead/"},{"name":"Algorithm Analysis","slug":"AfterRead/Algorithm-Analysis","permalink":"http://cybeird.github.io/categories/AfterRead/Algorithm-Analysis/"},{"name":"Software Engineering","slug":"AfterRead/Software-Engineering","permalink":"http://cybeird.github.io/categories/AfterRead/Software-Engineering/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://cybeird.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://cybeird.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"http://cybeird.github.io/tags/next/"},{"name":"Self-Contribute","slug":"Self-Contribute","permalink":"http://cybeird.github.io/tags/Self-Contribute/"},{"name":"Volantis","slug":"Volantis","permalink":"http://cybeird.github.io/tags/Volantis/"},{"name":"c艹","slug":"c艹","permalink":"http://cybeird.github.io/tags/c%E8%89%B9/"},{"name":"algorithm","slug":"algorithm","permalink":"http://cybeird.github.io/tags/algorithm/"},{"name":"binarySearch","slug":"binarySearch","permalink":"http://cybeird.github.io/tags/binarySearch/"},{"name":"FF14","slug":"FF14","permalink":"http://cybeird.github.io/tags/FF14/"},{"name":"SWE","slug":"SWE","permalink":"http://cybeird.github.io/tags/SWE/"},{"name":"daily","slug":"daily","permalink":"http://cybeird.github.io/tags/daily/"},{"name":"markdown","slug":"markdown","permalink":"http://cybeird.github.io/tags/markdown/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://cybeird.github.io/tags/Divide-and-Conquer/"},{"name":"mergeSort","slug":"mergeSort","permalink":"http://cybeird.github.io/tags/mergeSort/"},{"name":"Github","slug":"Github","permalink":"http://cybeird.github.io/tags/Github/"},{"name":"git","slug":"git","permalink":"http://cybeird.github.io/tags/git/"},{"name":"DOOM","slug":"DOOM","permalink":"http://cybeird.github.io/tags/DOOM/"},{"name":"mermaid","slug":"mermaid","permalink":"http://cybeird.github.io/tags/mermaid/"}]}